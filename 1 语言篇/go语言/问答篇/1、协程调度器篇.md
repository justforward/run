
# 协程和线程的区别

1.  一个线程可以有多个协程。
2.  大多数业务场景下，线程进程可以看做是同步机制，而协程则是异步。
3.  线程是抢占式，而协程是非抢占式的，所以需要用户代码释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。
4.  协程并不是取代线程，而且抽象于线程之上。线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行。

# 协程调度核心

	它会根据协程的状态和优先级来调度协程的执行，避免了线程切换和上下文切换的开销。同时，Go 运行时还提供了协程的抢占机制，可以在协程执行的过程中暂停它的执行，并将执行权转移到其他协程上，从而避免了某个协程长时间占用 CPU 的情况。

-   Goroutine（G）：代表 Go 语言中的协程，即轻量级线程。
-   M（Machine）：代表操作系统线程，Go 语言使用多个 M 来并发执行多个 Goroutine，M 负责将 Goroutine 映射到操作系统线程上运行。
-   P（Processor）： Go 语言中的逻辑处理器，是执行 Goroutine 的真正执行者，P 和 M 是一对一的关系，一个 M 对应一个 P。

P的作用调度器的功能是将待执行的任务调度到操作系统上的线程去执行。


![Pasted image 20221226170940.png](app://local/Users/mac/GolandProjects/%E7%AC%94%E8%AE%B0/0%20%E5%9B%BE%E7%89%87/Pasted%20image%2020221226170940.png?1672045780713)


1.  **全局队列**（Global Queue）：存放等待运行的协程。全局队列需要加锁。
2.  **P的本地队列**：每个调度器P所独有的，不需要加锁。同全局队列类似，存放的也是等待运行的协程，存的数量有限，不超过256个。新建G'时，G'优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列。
3.  **P列表**：所有的P都在程序启动时创建，并保存在数组中，最多有`GOMAXPROCS`(可配置)个。
4.  **M**：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空时，M也会尝试从全局队列**拿**一批G放到P的本地队列，或从其他P的本地队列**偷**一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。

新的协程创建的时候，优先加入P的本地队列，如果本地队列满的时候，就需要加入到全局队列中。



P和M的个数:

1) P的个数
	由启动的环境变量 $GOMAXPROCS 或者是由runtime的方法GOMAXPROCS()
(设置可同时使用的cpu个数)决定。这意味着在程序执行的任意时刻只有 $GOMAXPROCS个Goroutine正在同时执行。默认情况下，可用的 P 的数量等于 CPU 核心的数量，可以通过 GOMAXPROCS 环境变量进例如，要将可用的 P 数量设置为 4，可以在程序启动时使用命令 `GOMAXPROCS=4 go run main.go`。

2）M的个数
1）go语言本身的限制：go程序启动时候，会设置M的最大数量，默认10000 1w个，但是内核很难支持这么多的线程数，所以这个限制可以忽略

M和P之间没有太大的关系，当M出现阻塞的时候，有P进行执行，那么就会创建一个新的M。



调度器的设计策略：

复用线程：避免频繁的创建，销毁线程，而是对线程的复用。

1）work steading机制---线程复用机制  

当本线程无可运行的G时候，尝试从其他线程绑定的P偷取G，而不是销毁线程

2）hand off机制 —— 阻塞释放 

当本线程因为G进行系统调用阻塞时候，线程释放绑定的P，把P转移给其他空闲的线程执行

**利用并行**：GOMAXPROCS设置P的数量，最多有GOMAXPROCS个线程分布在CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS=核数/2 ，则最多利用了一半的CPU核数进行并发。

**抢占**：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在GO中，一个Goroutine最多占用CPU10ms，防止其他Goroutine被饿死，这个也是goroutine不同于coroutine的一个地方

