
# 什么是Goroutine 如何停止？

协程是 Go 语言中的一种轻量级线程，其不会像操作系统线程那样占用大量的系统资源，而是由 Go 语言的运行时调度器负责协程的调度和执行。协程可以在单个线程中实现多个协程的并发执行，这使得 Go 语言在并发编程中具有很高的效率和吞吐量。

Go 语言还提供了一些并发原语，例如通道（Channel）和锁（Mutex），可以用于协程之间的通信和共享数据的同步访问。

- 通道是 Go 语言中用于协程间通信的一种机制，可以实现协程之间的同步和数据传输，可以通过 make 函数创建一个通道。

- 锁是 Go 语言中实现共享数据访问的一种机制，可以使用 sync 包中的 Mutex 类型实现。锁可以防止多个协程同时访问共享数据，避免数据的竞争和不一致。

## channel 

select 的多路复用
在实践中通常会出现多个通道与多个协程进行通信的时候，我们不希望由于一个通道的读写陷入阻塞，影响到其他通道的正常读写操作。

通道底层原理

# 并发控制

## context



# 锁机制

## 原子性

原子操作是底层最基础的同步保证，通过原子操作可以构建起许多同步原语，比如：自旋锁、互斥锁、信号量等。

## 互斥锁原理

1）使用位图保存当前锁的状态，其中包含锁是否为锁定状态、正在等待被锁唤醒的协程数量、两个和饥饿模式有关的标志。
2）为了解决某一个协程可能长时间无法获取锁的问题，G1.9之后使用了饥饿模式。在饥饿模式下，unlock会唤醒最先申请加速的协程，从而保证公平性。


Go语言中的互斥锁采用的是自旋锁的方式，也就是在获取锁失败时会进行自旋等待，直到获取到锁才会返回。

在互斥锁中，还使用了一个饥饿模式来防止线程饥饿的情况发生。当一个线程等待锁的时间超过一定的阈值时，该线程将进入饥饿模式，它将不再参与锁的竞争，而是等待其它线程释放锁后再尝试获取锁。

饥饿模式的具体实现方法是，在互斥锁中维护一个等待队列，每个线程在尝试获取锁失败后都会加入到等待队列中。等待队列中的线程会按照先进先出的顺序等待获取锁，但如果等待时间超过了一定的阈值，该线程就会进入饥饿模式。进入饥饿模式后，该线程会将自己的优先级设置为最高，等待其它线程释放锁后再尝试获取锁

核心：
1）自旋方式，第一次获取失败的时候，尝试自旋等待锁，等待超过一定的阈值之后，加入到等待队列中。
2）饥饿模式，如果等待超过一定阈值，该线程进入饥饿模式将展开的优先级提升。

