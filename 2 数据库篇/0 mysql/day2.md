
# mysql的架构

分为三个层次：客户端层、服务端层和存储引擎层

1、客户端层：负责与用户交互、包括命令行工具、图形界面工具和应用程序
2、服务层：包括连接管理器、sql解析器、查询优化器、查询缓存、存储过程、触发器等，负责解析和执行SQL查询请求，并将结果返回给客户端。
3、存储引擎层：包括多种不同的存储引擎，INNODB、MYISAM等，负责数据的存储和管理，按照 MySQL 服务层下发的请求，通过索引或者全表扫描等方式把磁盘上的数据上传到 MySQL 服务层。

# 日志

主要三个日志：binlog（二进制日志）、redolog（重做日志）、undolog(回滚日志)

## binlog

记录数据库变化。包括对数据库进行修改的 SQL 语句或者语句对应的原始数据。
作用：
1）数据恢复：当mysql出现故障或者误操作导致数据损坏，通过将Binlog中的记录进行逆序执行，可以讲数据库恢复到之前某个时间点的状态。
2）主从复制：mysql的主从架构中，主库将自己的binlog传递给从库，从库根据binlog中的记录进行数据更新，实现主从同步。
3）数据追溯和安全审计：从binlog的记录中查看历史操作。

## redolog
用于保证myql事务的原子性和持久性。当事务进行修改操作时候，myql先将修改的数据记录到redolog中，然后在事务提交完成之后，将redo log中的记录刷写到磁盘中，用于保证修改的数据持久化到磁盘中。
写入的是物理日志，记录了对数据页的修改，

1）恢复数据：当msyql发生异常崩溃，可以通过redo log中的记录，恢复到崩溃之前的数据状态。

2）保证事务的原子性：在事务提交之前，mysql会降redo log中的记录写入磁盘，这样即使在事务提交之后出现异常，也可以通过redo log中的记录修改操作恢复到事务之前的状态，从而保证事务的原子性。

## undolog

用于支持事务的机制之一，主要用于事务的回滚和多版本并发控制（MVCC），记录逻辑日志，记录了事务在执行过程中对那些数据进行的修改。

1）支持事务的回滚：当一个事务执行失败或者被回滚时，muysql可以利用undolog来撤销事务执行过程中的修改操作。从而回滚事务，保证数据的一致性。
2）实现MVCC：当一个事务读取数据库中的某个数据时，mysql首先会查询undolog，查看该数据是否被其他事务修改过，如果改数据被修改过，mysql将读取undolog中该数据最新的版本，这样就可以实现多个事务并发访问数据库。

## redolog和binlog的区别

- 目的不同：redolog 用于保证数据的一致性和持久性，主要用于故障恢复和奔溃恢复，binlog记录对数据的修改，主要用于数据备份、数据恢复和主从复制。
- 写入时间不同：Redo Log在事务进行过程中不断写入，Binlog在事务提交时才会被写入
- 内容不同：redolog记录的是物理日志，记录了对数据页的修改操作，binlog记录的是逻辑日志（mysql语句？），记录了对数据进行的修改操作，包括对那些表的什么操作。

## 内部事务

#### 如何保证这两个日志的一致性问题？

问题所在：毕竟是两个文件，如何保证他俩的一致性，因为redolog是在事务执行的过程中不断的更新文件，所以有可能还没有搞完，执行完毕后，binlog挂了。

mysql采用的是两段提交的方式，写redolog时候先进入准备阶段，提交事务后，在binlog修改完成时，redolog再进行提交。这样在mysql根据redolog日志恢复数据的时候，一旦发现处于准备阶段，并且没有对应的binlog，那么事务会发生回滚（使用undolog进行事务的回滚）。



# 事务和锁

## mysq如何保证事务的

在数据库中，事务是一组被视为单个逻辑单元的操作序列，这些操作要么全部成功执行，要么全部失败回滚。

1）原子性
	一个事务中的所有操作，要么全部完成，要么全部不完成，不会出现部分完成的情况。MySQL 使用 redo log 和 undo log 来实现原子性。redo log 用于在事务提交前将修改的数据写入磁盘，undo log 用于在事务回滚时将修改的数据恢复到事务开始之前的状态。
2）一致性
	事务完成后，数据的状态应该是一致性的，mysql使用约束、触发器、存储过程等机制来保证。
3）隔离性
	一个事务的执行不应该收到其他事务的干扰，mysql使用锁的机制来实现隔离性。
4）持久性
	一个事务提交后，对数据所做出来的修改应该永久保存在数据库中，mysql使用redolog和binlog来实现持久性。redolog用于在崩溃后恢复数据的一致性，binlog用于在主从复制中同步数据。


### 事务的隔离性

1）未提交读
允许一个事务读取其他未提交的事务所写入的数据，会导致脏读问题。
2）已提交读
一个事务只能读取已经提交的数据，可以避免脏读，但是会导致不可重复读。不可重复读是一个事务在多次读取同一行数据时，可能会读取到不同的数据版本。
3）可重复读
保证在事务执行期间，多次读到同一个数据得到的结果是一致的，但是会出现幻读的问题。幻读是指在同一个事务中，前一次查询操作和后一次查询操作返回的数据集合不一致的现象，这种不一致由于其他事务插入了符合前一次查询条件的数据行导致的。
4）串行化
将事务进行串行化执行，确保每个事务按照串行的顺序执行，可以避免脏读，不可重复读和幻读的问题。但是会影响并发性能。


### 幻读和可重复读的区别
与不可以重复读的区别在于，不可以重复读主要是针对一个事务中多次读取同一数据行时，读取到的数据版本不一致的问题，而幻读则是针对同一个事务多次读取同一数据集合时，返回的数据行数量不一致的问题。


### mysql如何实现可重复读的

在 MySQL 中，可重复读（Repeatable Read）是通过在读取数据时加锁实现的。当一个事务开始时，它会在第一次访问一个数据行时自动加锁，直到事务结束时才释放锁。在这个过程中，其他事务无法修改被锁定的数据行，也无法向其添加新的数据行。

在实现可重复读的过程中，MySQL 还使用了一种称为 MVCC（Multi-Version Concurrency Control，多版本并发控制）的技术，它通过为每个事务生成一个单独的视图（view）来实现事务之间的隔离性。当一个事务开始时，它会创建一个视图，并在视图中存储当前数据库中所有正在执行的事务的快照。这样，即使其他事务正在执行修改操作，当前事务仍然可以读取到之前的数据版本，从而实现了可重复读。

需要注意的是，在可重复读的隔离级别下，当一个事务在读取一个数据行时，如果另一个事务已经更新了该数据行并提交了事务，但是当前事务还未结束，则当前事务会继续读取到之前的数据版本，而不是最新的数据版本。这种现象称为幻读（Phantom Read），可以通过使用锁或者使用一些特殊的语句（如 SELECT ... FOR UPDATE）来避免。

### mysql如何解决幻读

1）多版本并发控制来解决幻读
在每个事务看到的数据版本与其自身时间戳关联的，当事务对数据进行修改时，不会覆盖原来的数据行，而是为其创建一个新版本，并将新版本与当前事务的时间戳相关联，这样不同事务之间读取和修改的数据行都是相互独立的，不会相互干扰。

在mysql中，通过一下两种方式实现MVCC：

1.  Undo log：记录事务对数据行所做的修改操作，用于实现事务回滚和 MVCC。
2.  Read View：用于控制事务读取数据行的版本。在每个事务中，系统会为该事务创建一个 Read View，用于确定该事务可见的数据行版本范围

当一个事务需要读取某个数据行时候，系统会比较该事务的时间戳和数据行的版本号，确定数据行是否可见，如果该数据行的版本号早于改事务的时间戳，那么该数据行就是可见的，否则不可见。

通过实现MCVV，mysql能够在不加锁的情况下实现高并的读写操作，但是也会带来额外的存储开销。因为需要保存多个数据行的版本。

2）next-key 锁

通过在索引上的键值范围加锁来避免幻读。

是一种组合锁，同时使用了共享锁和排他锁，用于保护索引范围内的行。
当事务需要在一个索引范围内进行查询或者修改操作时，myql会在索引范围内进行查询或者修改操作时，mysql会在索引上的键值范围加入next-key锁。避免其他事务在这个范围内加入新的行或者修改已有的行。

Next-Key 锁主要用于 InnoDB 存储引擎中。

## 锁

MySQL提供了多种锁机制来保证并发事务的一致性和数据的完整性，主要包括以下几种：

1.  行级锁（Row-level Locking）：MySQL支持对单个行进行加锁，可以在读取或修改数据时加锁，其他事务不能修改或删除被锁定的行。行级锁分为共享锁（Shared Locks）和排它锁（Exclusive Locks）两种。
    
2.  表级锁（Table-level Locking）：MySQL支持对整个表进行加锁，当对表进行操作时，会对整个表进行锁定，其他事务无法对表进行修改或删除。表级锁包括表共享锁（Table Read Lock）和表排它锁（Table Write Lock）两种。

### 什么是意向锁

意向锁（Intention Lock）是一种表级别的锁，在 MySQL 中用于表示一个事务想要在表中的某个行上加哪种类型的行级别锁，以便其他事务在该行上加锁时可以知道哪些类型的锁已经被占用。它本身不会对表中的行加锁。

MySQL 中的意向锁有两种：

意向共享锁（Intention Shared Lock, IS）：表示一个事务想要在某个表的某个区间上加共享锁。
意向排他锁（Intention Exclusive Lock, IX）：表示一个事务想要在某个表的某个区间上加排他锁。
意向锁是一种优化锁机制，可以减少锁冲突，提高系统性能。例如，当一个事务要在某个行上加排他锁时，需要先获取表级别的意向排他锁（IX），这表示该事务要在表的某个区间上加排他锁，其他事务在该区间内只能加共享锁，而不能加排他锁。这样可以避免其他事务在该区间上加排他锁，产生锁冲突，提高了并发度和性能。

意向锁是一种优化锁机制，可以减少锁冲突，提高系统性能。例如，当一个事务要在某个行上加排他锁时，需要先获取表级别的意向排他锁（IX），这表示该事务要在表的某个区间上加排他锁，其他事务在该区间内只能加共享锁，而不能加排他锁。这样可以避免其他事务在该区间上加排他锁，产生锁冲突，提高了并发度和性能。

