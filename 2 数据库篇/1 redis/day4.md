
# 分布式锁

Redis的分布式锁是通过SETNX命令实现的，该命令可以将一个key设置为一个值，当且仅当该key不存在时才会设置成功。

1）客户端尝试获取锁，使用SETNX命令设置一个key-value，并设置一个过期时间，确保所在一定时间内能释放，避免死锁
2）如果SETNX命令返回1，表示获取锁成功，可以执行相关的操作，
3）如果SETNX命令返回0，表示所已经被其他客户端获取，当前客户端需要等待一段时间后重新尝试获取到锁。
4）执行完成后，客户端可以通过del命令释放锁。

但是无法保证客户端持有锁的情况下发生故障的时候导致锁无法释放。

## redlock算法

Redis RedLock 算法是一种分布式锁算法，它由Redis的作者Antirez在2015年提出。其主要思想是使用多个独立的 Redis 实例来实现分布式锁，以避免单点故障和数据丢失的问题。

具体来说，RedLock 算法使用一个锁服务和多个互相独立的 Redis 实例来实现分布式锁。其中锁服务负责协调各个 Redis 实例的加锁和解锁操作，并确保锁的安全性和可靠性。而各个 Redis 实例则负责存储锁的信息和执行加锁和解锁操作。

RedLock 算法主要分为以下几个步骤：

1）客户端获取当前时间戳，作为锁的有效期开始时间；
2）客户端依次向多个 Redis 实例尝试加锁，每个实例的加锁操作需要满足以下条件：
- 获取锁的超时时间不能超过一定的阈值；
- 锁的有效期不能小于一定的阈值；
- 获取锁的客户端和解锁的客户端必须是同一个；
- 客户端判断是否在多数 Redis 实例上成功加锁，如果是，则获取到了分布式锁；
3）客户端在获取到分布式锁后执行相应的操作，并在操作完成后向所有 Redis 实例执行解锁操作。

RedLock 算法虽然不能保证完全的分布式锁安全，但在实际使用中已经被广泛应用，并且相对于其他分布式锁算法而言，其具有更好的性能和可靠性。


# 事务

redis的事务是提供了一种将多个命令进行打包，然后一次性、有序地执行的机制。

是否可以保证ACID？Redis的事务具有ACID的原子性、一致性和隔离性，当服务运行在AOF持久性模式下，并且appendfsync=always的时候，事务也具有持久性。

## 1、原子性

可以保证，redis只对入命令队列的错误命令，比如命令不存在，或者命令格式不正确等进行检查进而拒绝执行。

**如何保证出现问题的时候进行回滚？**

虽说 Redis 不支持直接回滚，但我们可以通过 Redis 提供的watch命令监视一个或多个 key，如果被监视的 key 在事务执行前被修改过那么本次事务将会被取消，也就是所谓的回滚。

## 2、隔离性（Isolation）

隔离性：及时数据库中有多个事务并发执行，各个事务之间也不会相互影响。

Redis 的执行模型是使用单线程来执行的，并且服务器保证，在执行事务期间不会对事务进行中断，因此redis的事务总是以串行的方式运行的。保证隔离性

## 3、一致性

Redis 事务在执行的过程中，不会处理其它命令，而是等所有命令都执行完后，再处理其它命令。因此在 Redis 事务在执行过程中发生错误或进程被终结，都能保证数据的一致性。


## 4、持久性

当一个事务执行完毕之后，执行这个事务所得到的结果已经被保存在永久性存储介质中了，就算服务器在事务执行完毕之后进行宕机，执行的事务结果也不会被丢失。

redis的事务持久性是由redis所使用的持久化模式所决定的。

-   在 RDB 模式下，服务器只会在特定的保存条件满足的时候才会对数据进行备份。
-   在 AOF 模式下，如果开启了appendfsync= always时，事务的每条命令在执行成功之后，都会立即将命令数据真正保存在磁盘中，因此这种模式下可以支持持久性的。

