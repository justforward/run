
## 重点题目
1）redis的基本数据结构，string类型的数据结构 优点，跳表的过程


# 数据结构

## 基础
Redis的数据结构指的是Redis支持的不同类型的value的数据结构。

-   字符串（String）：存储单个的字符串
-   哈希（Hash）：key-value结构，用于存储字段和对应的值。
-   列表（List）：存储有序可重复的字符串列表。粉丝列表，文章评论
-   集合（Set）：存储不同重复的字符串集合。查看两个人共同的好友
-   有序集合（Sorted Sets）：和集合类似，但是每个元素可以关联一个分数。根据分数可以对元素进行排序。排行榜、
-   其他：位图（bitmap）、地理位置（Geo）--找到附近的人

## 原理

### hash

#### rehash

为了让哈希表的负载因子维持在一个合理范围内，当哈希表保存的键值对数值太多的时候，需要对哈希表的大小进行相应的扩展或者收缩。

#### 渐进式hash

在扩容和收缩的时候，如果哈希字典中有很多元素，一次性将这些键全部rehash到新的哈希表的话，可能会导致服务器在一段时间内停止服务。

所以，采用**渐进式rehash**的方式，详细步骤如下：
1.  为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表
2.  将索引计数器变量rehashindex的值设置为0，表示rehash工作正式开始
3.  在rehash期间，每次**对字典执行增删改查**操作是，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashindex索引上的所有键值对rehash到ht[1]，当rehash工作完成以后，rehashindex的值+1
4.  随着字典操作的不断执行，最终会在某一时间段上ht[0]的所有键值对都会被rehash到ht[1]，这时将**rehashindex****的值设置为****-1****，表示rehash操作结束**

渐进式rehash采用的是一种分而治之的方式，将rehash的操作分摊在每一个的访问中，避免集中式rehash而带来的庞大计算量。

需要注意的是在渐进式rehash的过程，字典会同时拥有ht[0]、ht[1]。如果有增删改查操作时，需要再这两个哈希表中都进行操作。比如查询操作，先在ht[0]中找，找不到再去h[1]中找，针对新增的键值一律都是保存在h[1]中。




### 跳跃表(skiplist)

有序集合（sorted set）中使用了跳表.

#### 什么是跳表？

跳表是一个值有序的链表建立多级索引之后的一种数据结构。跳表的空间复杂度是 O(n)，时间复杂度是 O(logn)，基于链表构建，比红黑树的维护更为简单。


1）首先它是一个list，在有序链表的基础上，新增链表指针进行跳跃指向，比如第一个链表节点跳过一个节点指向第二个节点。这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。

数据结构中：主要是层，每创建一个新跳跃表节点的时候，zskiplistnode 都会从1~32随机出来一个数值，作为层高，节点的层高决定了该节点再跳跃表中出现的位置，同时也影响了该节点被访问的概率。
层里面包含了前进指针（用于从表头向表尾方向访问节点）和跨度（在该层两个节点之间的距离）两个属性。

2）为了降低插入操作的复杂度，每新增一个节点，都会**随机生成一个层级**，这样新插入一个节点不会影响其它节点的层数。插入操作只需要修改插入节点前后的指针即可，而不需要对很多节点都进行调整。

![[Pasted image 20230312160231.png]]

假如想要查询 10 这个数据，那么先在二级索引层遍历，当遍历到二级索引中 7 这个索引节点之后，发现后面的一个索引节点的值是 13，那么10 这个数据节点肯定是在这两个索引节点之间。然后，我们通过 down 指针，下降到一级索引层继续遍历查找。这个时候遍历到 9 这个一级索引节点，而后面一个索引节点的值是 13，那么则继续通过 down 指针下降到原始链表继续遍历查找，从而找到 10 这个数据。

# 线程模型

单线程模型：基于单线程的文件事务处理器实现。

采用 **IO 多路复用机制**同时监听**多个 socket**，将产生事件的 socket 压入**内存队列**中，**事件分派器**根据 socket 上的**事件类型**来选择对应的**事件处理器**进行处理。

文件事件处理器的结构包含 4 个部分：

-   多个 socket
-   IO 多路复用程序
-   文件事件分派器
-   事件处理器（**连接应答**处理器、**命令请求**处理器、**命令回复**处理器）

举例：

客户端socket向Redis的进程发送一个请求，那么redis进程的server sokcet会将这个请求产生一个事件，IO多路复用程序监听到这个产生的事件就会将该socket放入队列中，文件分派器将从这个队列中获取到socket，根据事件类型来选在对应的事件处理器进行处理。


## 单线程为什么还那么快？

- 纯内存操作，内存数据库
- 基于非阻塞的io多路复用
- 单线程避免了多线程的上下文多次切换，还有并发锁机制。

## IO多路复用

什么是IO多路（网络连接多个socket）复用（同一个线程）机制？

理解：相当于一个线程监听多个网络连接（socket），如果某个文件句柄就绪那么就会通知响应的读写操作，如果没有文件句柄就绪就会把CPU的资源交出来。

#### 原理

服务器端采用单线程通过 select/poll/epoll 等系统调用获取 fd 列表，遍历有事件的 fd 进行 accept/recv/send ，使其能支持更多的并发连接请求

#### 1）select

使用数组进行存储所有的socket，每次将所有的流进行无差别轮询，找到就绪状态的socket文件描述符，对他们进行操作，时间复杂度O(n)

#### 2）poll

使用链表存储所有的socket，每次也是对所有的流进行无差别的轮询，时间复杂度为O(n),好处是链表形式 可以无限接入I/O操作

#### 3）epoll

**3.1 底层原理：红黑树**存储监控的文件描述符，**双链表**存储就绪的文件描述符，回调函数直接去双链表中获取就绪的文件描述符，这样降低了时间复杂度，O(1)



3.2 底层有流意义的事件：epoll可以理解为event poll，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）

**如何选择I/O多路复用**

1.  连接数较少并且都很活跃,用select和poll效率更高
2.  连接数较多并且都不很活跃,使用epoll效率更高（因为流存在事件驱动，所以需要）

## Redis 6.0 开始引入多线程

**提高网络读写性能**

**注意！** Redis 6.0 之后的版本抛弃了单线程模型这一设计，**原本使用单线程运行的 Redis 也开始选择性地使用多线程模型**。

因为读写网络的 Read/Write 系统调用在 Redis 执行期间占用了大部分 CPU 时间，如果把网络读写做成多线程的方式对性能会有很大提升。

**Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。** 之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务、LPUSH/LPOP 等等的并发问题。
