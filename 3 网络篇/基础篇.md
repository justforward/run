
-   [计算机网络体系结构](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)
-   [UDP 的主要特点](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#2-udp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9)
-   [TCP 的主要特点](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#3-tcp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9)
-   [简述三报文握手建立 TCP 连接](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#4-%E7%AE%80%E8%BF%B0%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5)
-   [建立 TCP 连接为什么最后还要发送确认](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#5-%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4)
-   [简述 TCP 连接的释放](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#6-%E7%AE%80%E8%BF%B0-tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE)
-   [TIME-WAIT 是什么，为什么必须等待 2MLS](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#7-time-wait-%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2mls)
-   [TCP 粘包问题](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#8-tcp-%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98)
-   [UDP、TCP 区别，适用场景](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#9-udptcp-%E5%8C%BA%E5%88%AB%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)
-   [建立 socket 需要哪些步骤](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#10-%E5%BB%BA%E7%AB%8B-socket-%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4)
-   [DNS 主要作用是什么](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#11-dns-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)
-   [HTTP 报文组成](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#12-http-%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90)
-   [HTTP 状态码](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#13-http-%E7%8A%B6%E6%80%81%E7%A0%81)
-   [常见的 HTTP 方法](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#14-%E5%B8%B8%E8%A7%81%E7%9A%84-http-%E6%96%B9%E6%B3%95)
-   [GET 与 POST 请求方式区别](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#15-get-%E4%B8%8E-post-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB)
-   [HTTP 优缺点](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#16-http-%E4%BC%98%E7%BC%BA%E7%82%B9)
-   [HTTPS 通信原理](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#17-https-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86)
-   [HTTP 2.0](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#18-http-20)
-   [WebSocket](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#19-websocket)
-   [IPv6 与 IPv4 有什么变化](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#20-ipv6-%E4%B8%8E-ipv4-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96)
-   [什么是心跳机制](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6)
-   [什么是长连接](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#22-%E4%BB%80%E4%B9%88%E6%98%AF%E9%95%BF%E8%BF%9E%E6%8E%A5)

# 传输层—TCP和UDP

## UDP的主要特点

无连接、不可靠、面对数据报、快速、支持多播和广播


## TCP的主要特点

面向连接（握手进行）、可靠性（序列号、确认应答机制、重传机制）、面向字节流（没有固定的消息边界，需要应用层对数据进行拆分和重组）

1.  流量控制：TCP 的发送方根据接收方的处理能力和网络的拥塞情况来控制发送数据的速率，以防止发送方的速度过快而导致接收方无法及时处理数据。
    
2.  拥塞控制：TCP 的发送方根据网络的拥塞程度来控制发送数据的速率，以避免过多的数据注入导致网络拥塞而导致丢包。
    
3.  可靠的错误检测和恢复：TCP 在数据传输过程中能够检测和恢复数据传输中的错误，如校验和不一致、丢包等情况

1）基于丢包的拥塞检测及处理：以丢包来检测拥塞并调整传输速度；RENO算法
2）基于延迟的拥塞检测及处理，以往返延迟（Round Trip Time,RTT）的变化来检测拥塞并调整传输速度

更有效的拥塞判断及处理； 更准确及时地进行丢包判断恢复制机制

拥塞恢复：
调整拥塞控制窗口（发送数据的窗口）的大小，当网络拥塞程度较高时，TCP会将拥塞窗口减小，反之则会将拥塞窗口逐渐增大。

BBR算法采用的是基于模型的拥塞控制方法，动态调整发送数据的窗口，通过利用网络链路传输的反馈信息，不断更新模型参数，使得模型的估算结果能够更加准确地反映网络链路的实际情况，从而实现更优秀的拥塞控制效果。


# 面向UDP的可靠连接

在 TCP 下，依然无法解决延迟问题，比如为防止初始阻塞而引入的慢启动；TCP 队头阻塞，比如由于发生丢包，整个连接涉及的传输数据都需要重传而引起的阻塞。

但是如果你有 2% 的丢包率，那 HTTP2 在性能上就没有优势了。

上图是造成 TCP 队头拥塞（Head of line blocking）的原因。HTTP2 协议是基于 TCP 的，但是 TCP 本身是无法解决队头拥塞，为什么呢？因为 HTTP2 会把一次传输所有的文件都放在一个 TCP 连接中，只要这个 TCP 中发生一个丢包，连接就必须重新建立，之前所有传输内容进行必须重传，从而造成拥塞

TCP本身无法解决队头拥塞的原因。

## TCP的三次握手

TCP 报文中两个重要的字段:一个是序号（ISN）字段——用于后续通信中序号的同步， 另一个是确认号（ACK）字段：用于确认对方发送的数据，


1）客户端向服务端发送不带任何数据的报文TCP报文，里面包含：SYN字段=1，并在自己那层记录这个报文
2）服务端接受到这个报文后，会进行相应，此时发送一个SYN—ACK报文，里面包含SYN=1，ACK=1.表示同意建立连接
3）客户端收到这个响应报文之后，再发送一个ACK报文，表示已经收到了服务器的确认，并且通信正式建立。

SYN的作用

1）让服务器知道客户端要建立连接
2）告诉服务器客户端的初始序号，在后续传输中通过这个序号。服务端来辨别来自哪个的信息。


## 什么是SYN超时和恶意攻击

1）SYN超时是指，客户端在发送链接请求之后，如果在指定的时间内没有收到服务器的SYN-ACK响应，那么客户端会进行重传。如果重传次数超过了一定的阈值，那么客户端会认为这次连接失败，并通知应用程序。

2）洪泛攻击

利用SYNC超时机制，攻击者通过向目标主机发送大量的SYN请求，但不发送ACK响应，导致目标主机上的所有连接队列都被占用，从而无法接收新的连接请求，从而使得正常的连接请求被拒绝。

解决方案：通过SYNC cookie，

当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只 是打开一个半开的套接字。然后使用双方约定的函数生成cookie进行响应验证。


## TCP的四次挥手

TCP的四次挥手过程如下：
1.  客户端发送一个FIN报文给服务器，表示客户端不再发送数据。
2.  服务器收到FIN报文后，发送一个ACK报文给客户端确认已经收到FIN报文。
4.  服务器发送一个FIN报文给客户端，表示服务器已经完成数据发送。
5.  客户端收到FIN报文后，发送一个ACK报文给服务器确认已经收到FIN报文。

TCP是双工通信的：1和2步是为了客户端进行断开连接请求，3，4是服务端进行断开连接请求。

#为什么需要time_wait？为什么要等待2s

TIME_WAIT 是指在 TCP 连接中，当一方向另一方发送了 FIN 报文（表示自己已经没有数据要发送了）后，就进入 TIME_WAIT 状态。这个状态的作用是保证在这段时间内，双方都能确保数据传输成功，防止已经传输的数据丢失，从而确保了数据的完整性。

TIME_WAIT状态的持续时间通常是2倍MSL，因为TCP包的最大生存期为MSL，这样可以确保所有可能的延迟报文都已被丢弃

#什么情况下会出现close_wait的情况

`close_wait` 是一种 TCP 状态，表示一个连接已经被对端关闭，但本地端仍然有数据需要发送，因此等待本地应用程序调用 `close()` 关闭本地连接。在这种状态下，本地端等待的是应用程序关闭连接的时间，而不是对端关闭连接的时间。如果本地应用程序没有及时关闭连接，则可能会导致


# 应用层—http协议

# 响应码

4x：

400 Bad Request 客户端请求的语法错误，服务器无法理解

401 Unauthorized 请求要求用户的身份认证

403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求

404 Not Found 服务器无法根据客户端的请求找到资源（网页）

5x：
500 internel server error 服务内部错误
503 Service Unavailable 服务出现负载严重，暂时处于不可用的状态，

这两种异常状态码都与网关 Gateway 有关，首先明确两个概念

-   Proxy (Gateway)，反向代理层或者网关层。在公司级应用中一般使用 Nginx 扮演这个角色
-   Application (upstream serrver)，应用层服务，作为 Proxy 层的上游服务。在公司中一般为各种语言编写的服务器应用，如 Go/Java/Python/PHP/Node 等

-   `502 Bad Gateway`。一般表现为你自己写的应用层服务(Java/Go/PHP)挂了，网关层无法接收到响应
-   `504 Gateway Timeout`。一般表现为应用层服务 (upstream) 超时，如查库操作耗时十分钟，超过了 Nginx 配置的超时时间。


# 断点续传的Etag


关于 `etag` 的生成需要满足几个条件，至少是宽松满足

1.  当文件更改时，`etag` 值必须改变。
2.  **尽量**便于计算，不会特别耗 CPU。这样子利用摘要算法生成 (MD5, SHA128, SHA256) 需要慎重考虑，因为他们是 CPU 密集型运算
3.  **必须**横向扩展，分布式部署时多个服务器节点上生成的 `etag` 值保持一致。这样子 `inode` 就排除了



`ginx` 中的 `etag` 由 `last_modified` 与 `content_length` 组成，而 `last_modified` 又由 `mtime` 组成

当编辑文件却未更改文件内容时，或者 `touch file`，`mtime` 也会改变，此时 `etag` 改变，但是文件内容没有更改。


# TCP粘包

TCP粘包是指发送方发送的若干包数据到接收方接受时粘成一包，

粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。

为什么会出现TCP粘包问题？

TCP协议是一种面向连接的可靠传输协议，在传输数据时需要建立连接、维护状态和进行流量控制等操作，这些操作都需要消耗一定的网络资源和时间。为了提高传输效率和减少网络负载，TCP协议会对传输的数据进行优化和合并，将多个小的数据包合并成一个大的数据块进行传输，这就是TCP粘包问题的根源。
相比之下，UDP协议是一种无连接的不可靠传输协议，没有TCP协议那么复杂的连接状态和流量控制机制，因此不会像TCP协议那样对数据进行优化和合并，每个UDP数据包都是独立的，不会发生粘包现象。

TCP是个"流"协议，所谓流，就是没有界限的一串数据，大家可以想想河里的流水，是连成一片的，其间是没有分界线的。但一般通讯程序开发是需要定义一个个相互独立的数据包的，比如用于登陆的数据包，用于注销的数据包。由于TCP"流"的特性以及网络状况，在进行数据传输时会出现以下几种情况。


假设我们连续调用两次send分别发送两段数据data1和data2,在接收端有以下几种接收情况(当然不止这几种情况,这里只列出了有代表性的情况).

A.先接收到data1,然后接收到data2.
B.先接收到data1的部分数据,然后接收到data1余下的部分以及data2的全部.
C.先接收到了data1的全部数据和data2的部分数据,然后接收到了data2的余下的数据.
D.一次性接收到了data1和data2的全部数据.


1.由Nagle算法造成的发送端的粘包:Nagle算法是一种改善网络传输效率的算法.简单的说,当我们提交一段数据给TCP发送时,TCP并不立刻发送此段数据,而是等待一小段时间,看看在等待期间是否还有要发送的数据,若有则会一次把这两段数据发送出去.这是对Nagle算法一个简单的解释,详细的请看相关书籍. C和D的情况就有可能是Nagle算法造成的.

2.接收端接收不及时造成的接收端粘包:TCP会把接收到的数据存在自己的缓冲区中,然后通知应用层取数据.当应用层由于某些原因不能及时的把TCP的数据取出来,就会造成TCP缓冲区中存放了几段数据.

针对这个问题，一般有3种解决方案：

(1)发送固长度的消息，

(2)消息里面添加尺寸信息

(3)使用特殊标记来区分消息间隔



# 建立Socket需要哪些步骤

在 Linux 操作系统中，Socket 是介于应用层与传输层中间的软件抽象层，它是一组接口，可以说 Socket 是 TCP/IP 协议栈对外的窗口。

创建socket应用程序一般要经过下面6 个步骤。

1.  创建Socket；
2.  将Socket与地址绑定，设置Socket选项；
3.  建立Socket之间的连接；
4.  监听Socket；
5.  接收、发送数据；
6.  关闭、释放Socket；


TCP编程的服务器端一般步骤是：  
1、创建一个socket，用函数socket()；  
2、设置socket属性，用函数setsockopt(); * 可选  
3、绑定IP地址、端口等信息到socket上，用函数bind();  
4、开启监听，用函数listen()；  
5、接收客户端上来的连接，用函数accept()；  
6、收发数据，用函数send()和recv()，或者read()和write();  
7、关闭网络连接；  
8、关闭监听；  
  

struct sockaddr_in addr; 定义一个ip地址

TCP编程的客户端一般步骤是：  
1、创建一个socket，用函数socket()；  
2、设置socket属性，用函数setsockopt();* 可选  
3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选  
4、设置要连接的对方的IP地址和端口等属性；  
5、连接服务器，用函数connect()；  
6、收发数据，用函数send()和recv()，或者read()和write();  
7、关闭网络连接；

UDP编程的服务器端一般步骤是：  
  
1、创建一个socket，用函数socket()；  
2、设置socket属性，用函数setsockopt();* 可选  
3、绑定IP地址、端口等信息到socket上，用函数bind();  
4、循环接收数据，用函数recvfrom();  
5、关闭网络连接；  

  
UDP编程的客户端一般步骤是：  
1、创建一个socket，用函数socket()；  
2、设置socket属性，用函数setsockopt();* 可选  
3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选  
4、设置对方的IP地址和端口等属性;  
5、发送数据，用函数sendto();  
6、关闭网络连接；


说明：在内核中，为每个Socket维护两个队列。一个是已经建立了连接的队列(三次握手已经完毕)，处于established状态；一个是还没有完全建立连接的(未完成三次握手)，处于syn_rcvd的状态。


# Http的优缺点

HTTP优点：
简单、灵活、易于扩展，应用广泛、软硬件环境成熟、无状态
HTTP协议很简单，报文格式就是header+body，头部信息也是简单的文本格式。
HTTP易于扩展不限制具体的下层协议，下层协议可以随意变化，上层的语义却可以始终保持稳定。

应用广泛、软硬件环境成熟
http在应用领域和开发领域都得到广泛的支持，HTTP天然具有跨语言、跨平台的特性，几乎所有编程语言都有HTTP调用库和外围的开发测试工具

无状态
无状态令服务器不需要额外的资源来记录状态信息，负担轻一些，很容易支持集群。

但是带来一定缺点，无法进行服务身份的认证，这里会采用cookie seesion 进行鉴定身份


HTTP缺点：
明文传输、不安全、性能不算差但也不够好
明文的意思就是协议里的报文header部分，不使用二进制数据，而使用简单可阅读的文本形式。

不安全
HTTP没有提供有效的手段来确认通信双方的真实身份，虽然有基本的认证机制，但在明文传输面前几乎等同无效。
HTTP也不支持完整性校验，数据在传输过程中很容易被篡改而无法验证真伪。
正是因为这个缺陷，所以出现了HTTPS。


# Https的通信过程

**三、HTTPS的通信过程**

https通信是建立在ssl连接层上的，需要客户端携带证书认证与服务端进行通信。

对称加密：加、解密使用的同一串密钥。
非对称加密：加、解密使用不同的密钥、一把作为公开的密钥、另一把作为非公开的私钥。

**通信过程如下 ：**

1、客户端和服务器端通过TCP建立连接，并发送https请求。

2、服务器响应请求，并将数字证书发送给客户端，数字证书包括公钥、域名、申请证书的公司。 

3、客户端收到服务器端的数字证书之后，会验证数字证书的合法性。

4、如果公钥合格，客户端生成对称加密的密钥，使用服务端的公钥对密钥进行非对称加密

5、客户端会再次发起请求，将加密之后的客户端密钥发送给服务器。

6、服务器接收密文后，会用私钥对其进行非对称解密，得到客户端秘钥。并使用客户端秘钥进行对称加密，生成密文并发送。

7、客户端收到密文，并使用客户端秘钥进行解密，获取数据。


核心：客户端得到服务端发送的公钥，然后生成对称加密的密钥，使用服务端的公钥对密钥进行加密，发送给服务端，服务端会私用私钥对这个解密，得到这个密钥，然后使用这个密钥对文件进行加密，发送给服务端。




# HTTP2.0和HTTP1.X相比的新特性

-   **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
    
-   **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
    
-   **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
    
-   **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。


http2的性能高于http1的原因？
在HTTP/2中，在应用层（[HTTP2](https://so.csdn.net/so/search?q=HTTP2&spm=1001.2101.3001.7020).0）和传输层（TCP或者UDP）之间加了一层：二进制分帧层。
二进制分帧是前提。
1）二进制分帧
在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。http2.0通信在一个链接上完成，这个链接可以承载任意数据量的双向数据流。

![[Pasted image 20230223112533.png]]

2）多路复用

在HTTP1.1中，如果客户端想发送多个并行的请求，必须使用多个TCP连接，而HTTP2的二进制分帧层突破了这一限制，所有的请求和响应都在同一个TCP连接上完成，单个连接可以承载任意数量的双向数据流，数据流以消息的形式发送，消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为可以根据帧首部的流标识符进行重新组装。


上面的特性使得性能有了极大的性能提升，原因如下：
因为同一个域名只需要占用一个TCP连接，使用这个连接并行发送多个请求和响应，这样使得整个页面的资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接带来的竞争问题。

# HTTP3的优势

主要是集中如何提高传输效率

1）进一步支持多路复用：stream方式。一般传输多少个文件就会产生对应数量的stream，当这些文件中的其中一个发生丢包的时候，只需要重传丢包文件对应的stream即可。

2）http3在传输层是基于UDP进行传输的，将在内核态进行的可靠性传输保证，放在在用户空间进行保证，相比 TCP，提高了连接建立的速度，降低了延迟

实现的方式：
https://www.upyun.com/tech/article/558/QUIC%2FHTTP3%20%E5%8D%8F%E8%AE%AE%E7%AE%80%E6%9E%90.html

cloudflare 那样，先在外面进行整合，然后再讲整合链接转到 Nginx 内。


# WebSocket

_WebSocket_是HTML5新增的_协议_，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。它基于TCP传输协议，并复用HTTP的握手通道。

为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。

为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。

什么是全双工通信？

全双工通信又称为双向同时通信，即**通信的双方可以同时发送和接收信息的信息交互方式**。 



# 什么是长连接

1.1）连接复用
1.2）进行多次数据传输
1.3）用于需要频繁进行通信的场景

长连接指的是在一定时间内，客户端和服务器之间保持网络连接不断开，以便于后续的请求和响应可以复用这个已建立的连接，从而避免每次请求都需要重新建立连接所带来的额外开销。在长连接中，一旦建立了连接，客户端和服务器之间可以进行多次数据传输，直到连接被关闭或达到一定的超时时间。相对于短连接，长连接可以减少因频繁建立和断开连接而产生的网络开销和延迟，提高网络传输的效率。长连接通常应用于需要频繁进行通信的场景，例如HTTP的Keep-Alive机制，Websocket等

# 什么是心跳机制

心跳机制是一种用于保持客户端和服务端连接状态的机制。在长连接中，为了避免因为网络故障等原因导致连接断开，通常会通过定期发送心跳包的方式来告知对方连接还处于存活状态。一般情况下，客户端和服务端都会定期互相发送心跳包，以保证连接的持久性和稳定性。当一个连接长时间没有收到心跳包时，就会认为该连接已经断开，并进行相应的处理，比如关闭连接或重新连接。心跳机制在实际应用中被广泛使用，例如TCP长连接、WebSocket。

