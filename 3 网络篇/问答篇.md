
-   [计算机网络体系结构](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84)
-   [UDP 的主要特点](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#2-udp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9)
-   [TCP 的主要特点](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#3-tcp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9)
-   [简述三报文握手建立 TCP 连接](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#4-%E7%AE%80%E8%BF%B0%E4%B8%89%E6%8A%A5%E6%96%87%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5)
-   [建立 TCP 连接为什么最后还要发送确认](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#5-%E5%BB%BA%E7%AB%8B-tcp-%E8%BF%9E%E6%8E%A5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E5%8F%91%E9%80%81%E7%A1%AE%E8%AE%A4)
-   [简述 TCP 连接的释放](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#6-%E7%AE%80%E8%BF%B0-tcp-%E8%BF%9E%E6%8E%A5%E7%9A%84%E9%87%8A%E6%94%BE)
-   [TIME-WAIT 是什么，为什么必须等待 2MLS](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#7-time-wait-%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E7%AD%89%E5%BE%85-2mls)
-   [TCP 粘包问题](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#8-tcp-%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98)
-   [UDP、TCP 区别，适用场景](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#9-udptcp-%E5%8C%BA%E5%88%AB%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF)
-   [建立 socket 需要哪些步骤](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#10-%E5%BB%BA%E7%AB%8B-socket-%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4)
-   [DNS 主要作用是什么](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#11-dns-%E4%B8%BB%E8%A6%81%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88)
-   [HTTP 报文组成](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#12-http-%E6%8A%A5%E6%96%87%E7%BB%84%E6%88%90)
-   [HTTP 状态码](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#13-http-%E7%8A%B6%E6%80%81%E7%A0%81)
-   [常见的 HTTP 方法](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#14-%E5%B8%B8%E8%A7%81%E7%9A%84-http-%E6%96%B9%E6%B3%95)
-   [GET 与 POST 请求方式区别](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#15-get-%E4%B8%8E-post-%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%E5%8C%BA%E5%88%AB)
-   [HTTP 优缺点](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#16-http-%E4%BC%98%E7%BC%BA%E7%82%B9)
-   [HTTPS 通信原理](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#17-https-%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86)
-   [HTTP 2.0](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#18-http-20)
-   [WebSocket](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#19-websocket)
-   [IPv6 与 IPv4 有什么变化](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#20-ipv6-%E4%B8%8E-ipv4-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8F%98%E5%8C%96)
-   [什么是心跳机制](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#21-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6)
-   [什么是长连接](https://github.com/studygolang/Go-Interview-QA/blob/master/docs/01.%E7%BD%91%E7%BB%9C/QA.md#22-%E4%BB%80%E4%B9%88%E6%98%AF%E9%95%BF%E8%BF%9E%E6%8E%A5)






# TCP粘包

TCP粘包是指发送方发送的若干包数据到接收方接受时粘成一包，

粘包拆包问题是处于网络比较底层的问题，在数据链路层、网络层以及传输层都有可能发生。我们日常的网络应用开发大都在传输层进行，由于UDP有消息保护边界，不会发生粘包拆包问题，因此粘包拆包问题只发生在TCP协议中。

为什么会出现TCP粘包问题？

TCP协议是一种面向连接的可靠传输协议，在传输数据时需要建立连接、维护状态和进行流量控制等操作，这些操作都需要消耗一定的网络资源和时间。为了提高传输效率和减少网络负载，TCP协议会对传输的数据进行优化和合并，将多个小的数据包合并成一个大的数据块进行传输，这就是TCP粘包问题的根源。
相比之下，UDP协议是一种无连接的不可靠传输协议，没有TCP协议那么复杂的连接状态和流量控制机制，因此不会像TCP协议那样对数据进行优化和合并，每个UDP数据包都是独立的，不会发生粘包现象。

TCP是个"流"协议，所谓流，就是没有界限的一串数据，大家可以想想河里的流水，是连成一片的，其间是没有分界线的。但一般通讯程序开发是需要定义一个个相互独立的数据包的，比如用于登陆的数据包，用于注销的数据包。由于TCP"流"的特性以及网络状况，在进行数据传输时会出现以下几种情况。


假设我们连续调用两次send分别发送两段数据data1和data2,在接收端有以下几种接收情况(当然不止这几种情况,这里只列出了有代表性的情况).

A.先接收到data1,然后接收到data2.
B.先接收到data1的部分数据,然后接收到data1余下的部分以及data2的全部.
C.先接收到了data1的全部数据和data2的部分数据,然后接收到了data2的余下的数据.
D.一次性接收到了data1和data2的全部数据.


1.由Nagle算法造成的发送端的粘包:Nagle算法是一种改善网络传输效率的算法.简单的说,当我们提交一段数据给TCP发送时,TCP并不立刻发送此段数据,而是等待一小段时间,看看在等待期间是否还有要发送的数据,若有则会一次把这两段数据发送出去.这是对Nagle算法一个简单的解释,详细的请看相关书籍. C和D的情况就有可能是Nagle算法造成的.

2.接收端接收不及时造成的接收端粘包:TCP会把接收到的数据存在自己的缓冲区中,然后通知应用层取数据.当应用层由于某些原因不能及时的把TCP的数据取出来,就会造成TCP缓冲区中存放了几段数据.

针对这个问题，一般有3种解决方案：

(1)发送固长度的消息，

(2)消息里面添加尺寸信息

(3)使用特殊标记来区分消息间隔



# 建立Socket需要哪些步骤

在 Linux 操作系统中，Socket 是介于应用层与传输层中间的软件抽象层，它是一组接口，可以说 Socket 是 TCP/IP 协议栈对外的窗口。

创建socket应用程序一般要经过下面6 个步骤。

1.  创建Socket；
2.  将Socket与地址绑定，设置Socket选项；
3.  建立Socket之间的连接；
4.  监听Socket；
5.  接收、发送数据；
6.  关闭、释放Socket；


TCP编程的服务器端一般步骤是：  
1、创建一个socket，用函数socket()；  
2、设置socket属性，用函数setsockopt(); * 可选  
3、绑定IP地址、端口等信息到socket上，用函数bind();  
4、开启监听，用函数listen()；  
5、接收客户端上来的连接，用函数accept()；  
6、收发数据，用函数send()和recv()，或者read()和write();  
7、关闭网络连接；  
8、关闭监听；  
  

struct sockaddr_in addr; 定义一个ip地址

TCP编程的客户端一般步骤是：  
1、创建一个socket，用函数socket()；  
2、设置socket属性，用函数setsockopt();* 可选  
3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选  
4、设置要连接的对方的IP地址和端口等属性；  
5、连接服务器，用函数connect()；  
6、收发数据，用函数send()和recv()，或者read()和write();  
7、关闭网络连接；

UDP编程的服务器端一般步骤是：  
  
1、创建一个socket，用函数socket()；  
2、设置socket属性，用函数setsockopt();* 可选  
3、绑定IP地址、端口等信息到socket上，用函数bind();  
4、循环接收数据，用函数recvfrom();  
5、关闭网络连接；  

  
UDP编程的客户端一般步骤是：  
1、创建一个socket，用函数socket()；  
2、设置socket属性，用函数setsockopt();* 可选  
3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选  
4、设置对方的IP地址和端口等属性;  
5、发送数据，用函数sendto();  
6、关闭网络连接；


说明：在内核中，为每个Socket维护两个队列。一个是已经建立了连接的队列(三次握手已经完毕)，处于established状态；一个是还没有完全建立连接的(未完成三次握手)，处于syn_rcvd的状态。


# Http的优缺点

HTTP优点：
简单、灵活、易于扩展，应用广泛、软硬件环境成熟、无状态
HTTP协议很简单，报文格式就是header+body，头部信息也是简单的文本格式。
HTTP易于扩展不限制具体的下层协议，下层协议可以随意变化，上层的语义却可以始终保持稳定。

应用广泛、软硬件环境成熟
http在应用领域和开发领域都得到广泛的支持，HTTP天然具有跨语言、跨平台的特性，几乎所有编程语言都有HTTP调用库和外围的开发测试工具

无状态
无状态令服务器不需要额外的资源来记录状态信息，负担轻一些，很容易支持集群。

但是带来一定缺点，无法进行服务身份的认证，这里会采用cookie seesion 进行鉴定身份


HTTP缺点：
明文传输、不安全、性能不算差但也不够好
明文的意思就是协议里的报文header部分，不使用二进制数据，而使用简单可阅读的文本形式。

不安全
HTTP没有提供有效的手段来确认通信双方的真实身份，虽然有基本的认证机制，但在明文传输面前几乎等同无效。
HTTP也不支持完整性校验，数据在传输过程中很容易被篡改而无法验证真伪。
正是因为这个缺陷，所以出现了HTTPS。


# Https的通信过程

**三、HTTPS的通信过程**

https通信是建立在ssl连接层上的，需要客户端携带证书认证与服务端进行通信。

对称加密：加、解密使用的同一串密钥。
非对称加密：加、解密使用不同的密钥、一把作为公开的密钥、另一把作为非公开的私钥。

**通信过程如下 ：**

1、客户端和服务器端通过TCP建立连接，并发送https请求。

2、服务器响应请求，并将数字证书发送给客户端，数字证书包括公钥、域名、申请证书的公司。 

3、客户端收到服务器端的数字证书之后，会验证数字证书的合法性。

4、如果公钥合格，客户端生成对称加密的密钥，使用服务端的公钥对密钥进行非对称加密

5、客户端会再次发起请求，将加密之后的客户端密钥发送给服务器。

6、服务器接收密文后，会用私钥对其进行非对称解密，得到客户端秘钥。并使用客户端秘钥进行对称加密，生成密文并发送。

7、客户端收到密文，并使用客户端秘钥进行解密，获取数据。


核心：客户端得到服务端发送的公钥，然后生成对称加密的密钥，使用服务端的公钥对密钥进行加密，发送给服务端，服务端会私用私钥对这个解密，得到这个密钥，然后使用这个密钥对文件进行加密，发送给服务端。




**HTTP2.0和HTTP1.X相比的新特性**

-   **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
    
-   **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。
    
-   **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
    
-   **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。
    

新的二进制格式可以支持到多路复用


在HTTP/2中，在应用层（[HTTP2](https://so.csdn.net/so/search?q=HTTP2&spm=1001.2101.3001.7020).0）和传输层（TCP或者UDP）之间加了一层：二进制分帧层。这是HTTP2中最大的改变。HTTP2之所以性能会比HTTP1.1有那么大的提高，很大程度上正是由于这一层的引入。


在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。

![[Pasted image 20230223112533.png]]



HTTP2.0通信都在一个连接上完成，这个连接可以承载任意数据量的双向数据流。相应地，每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。HTTP2.0的所有帧都采用二进制编码，所有首部数据都会被压缩。

在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。

多路复用

在HTTP1.1中，如果客户端想发送多个并行的请求，必须使用多个TCP连接，而HTTP2的二进制分帧层突破了这一限制，所有的请求和响应都在同一个TCP连接上完成，单个连接可以承载任意数量的双向数据流，数据流以消息的形式发送，消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为可以根据帧首部的流标识符进行重新组装。

上面的特性使得性能有了极大的性能提升，原因如下：

因为同一个域名只需要占用一个TCP连接，使用这个连接并行发送多个请求和响应，这样使得整个页面的资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接带来的竞争问题。

可以并行交错的发送多个请求或响应，这些请求或响应之间互不影响



# WebSocket

_WebSocket_是HTML5新增的_协议_，它的目的是在浏览器和服务器之间建立一个不受限的双向通信的通道，比如说，服务器可以在任意时刻发送消息给浏览器。它基于TCP传输协议，并复用HTTP的握手通道。

为什么传统的HTTP协议不能做到WebSocket实现的功能？这是因为HTTP协议是一个请求－响应协议，请求必须先由浏览器发给服务器，服务器才能响应这个请求，再把数据发送给浏览器。换句话说，浏览器不主动请求，服务器是没法主动发数据给浏览器的。

为什么WebSocket连接可以实现全双工通信而HTTP连接不行呢？实际上HTTP协议是建立在TCP协议之上的，TCP协议本身就实现了全双工通信，但是HTTP协议的请求－应答机制限制了全双工通信。WebSocket连接建立以后，其实只是简单规定了一下：接下来，咱们通信就不使用HTTP协议了，直接互相发数据吧。

什么是全双工通信？

全双工通信又称为双向同时通信，即**通信的双方可以同时发送和接收信息的信息交互方式**。 

