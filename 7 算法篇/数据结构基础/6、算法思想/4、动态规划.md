
# 一维动态规划

## 爬楼梯

```
1、dp[i]表示到楼梯i所有的方法
2、dp[n]的推导过程 
```

## 房屋偷窃

```
1、dp[i] 表示前i个房子在满足条件的情况下，所能偷窃到的最大价值
2) dp[n]推导
  2.1）要么dp[n] 不进行偷盗，那么是从dp[i-1] 中进行偷盗
  2.2）要么dp[n]进行偷盗，从dp[i-2]中得到，+nums[i-1]的值（这个是n所在的价值） 
```

## 环形的房屋偷窃


**我们只需要对`nums[0:n-2]`和`nums[1:n-1]`(闭区间)分别做一次上述题目同款的动态规划，返回较大值即可**。

dp[i] 表示前i个房子在满足条件的情况下，所能偷窃的最大价值。

```java
public int rob(int[] nums) {  
    int n = nums.length;  
    // 找到排序后的最大值  
    if (n <= 3) {  
        int max = 0;  
        for (int i = 0; i < n; i++) {  
            max = Math.max(max, nums[i]);  
        }  
        return max;  
    }  
    return Math.max(call(nums, 0, n - 1), call(nums, 1, n));  
}  
  
public int call(int[] nums, int l, int r) {  
    int n = nums.length;  
    int[] dp = new int[n + 1];  
    dp[l] = 0;  
    dp[l + 1] = nums[l];  
    for (int i = l + 2; i <= r; i++) {  
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);  
    }  
    return dp[r];  
}

```


# 二维动态规划

## 反转字符串

```
1、dp[i][j] 下标和定义

dp[i][0] 表示前i个递增元素且最后一个元素为0的最小反转次数
dp[i][1] 表示前i个元素递增且最后一个元素为1的最小反转次数

2、递推公式
如果前i个元素最后为0为结尾且满足单调递增，那么前i个元素必须全部是0，
dp[i][0]=dp[i-1][0]+s.chatAt(i)=='0'?0:1

dp[i][1]只要是满足最后一个元素为1即可，那么前i-1个元素即可以是0，也可以是1，

dp[i][1]=min(dp[i-1][1],dp[i-1][0])+(s.chatAt(i)=='1'?0:1)

最后比较dp[i][0] dp[i][1]中的较小即可
```


## 最长回文子串

```
dp[i][j] 表示下标i到下标j的字符串是否是回文串
```

```java
//longestPalindrome 最长回文子串  
public String longestPalindrome(String s) {  
    int max = 0;  
    int left = 0;  
    int right = 0;  
    int n = s.length();  
    boolean[][] dp = new boolean[n][n]; // dp[i][j]表示从i到j的字符串是否是回文串  
  
    for (int i = 1; i < n; i++) {  
        for (int j = 0; j < i; j++) {  
            if (s.charAt(i) != s.charAt(j)) {  
                continue;  
            }  
            // 单个单词a 或者 aa这种两个单词的 
            if (j + 1 >= i - 1) {  
                dp[i][j] = true;  
            } else {  
                dp[i][j] = dp[i - 1][j + 1];  
            }  
  
            if (dp[i][j] && i - j + 1 > max) {  
                max = i - j + 1;  
                left = j;  
                right = i;  
            }  
        }  
    }  
  
    return s.substring(left, right + 1);  
}
```


## 最长公共子序列

```
1、dp[i][j] 表示text1的前i个字符和 text2的前j个字符之间最长的公共子序列

2、递推
如果s.chatAt(i)===s.chatAt(j) dp[i][j]=dp[i-1][j-1]+1

如果不相等，max(dp[i-1][j],dp[i][j-1])

```

```java
int n1 = text1.length();  
int n2 = text2.length();  
int[][] dp = new int[n1 + 1][n2 + 1];  
  
for (int i = 1; i <= n1; i++) {  
    char c1 = text1.charAt(i-1);  
    for (int j = 1; j <= n2; j++) {  
        char c2 = text2.charAt(j-1);  
        if (c1 == c2) {  
            dp[i][j] = dp[i - 1][j - 1] + 1;  
        } else {  
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);  
        }  
    }  
}  
return dp[n1][n2];
```