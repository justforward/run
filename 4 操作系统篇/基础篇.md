# 进程与线程的切换流程


核心：每个进程都有自己的虚拟内存空间，而线程是共享所在进程的虚拟地址空间的。同一个进程的线程切换的时候不涉及虚拟地址空间的切换

进程切换分两步: 
1、切换页表以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存 的内存地址一瞬间都作废了。  
2、切换内核栈和硬件上下文。  
对于 linux 来说，线程和进程的最大区别就在于地址空间，对于线程切换，第 1 步是不需要做的，第 2 步是进程和线程切换都要做的。 因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空 间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。

# 进程间的通信有哪些

1）管道：局限：1）半双工的通信，数据只能单向流动，2）只能在具有亲缘关系的进程间使用。
				分为两类：匿名管道和命名管道。
				1）匿名管道是在两个具有血缘关系的进程之间，只存在于内存中。
				2）命名管道是以磁盘文件为载体的。可以在任意两个进程之间通信。
2）信号:信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，
而无需知道该进程的状态
3）信号量:信号量是一个计数器，可以用来控制多个进程对共享资源的访 问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也 访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步 手段。
4）socket 可以用于不同机器间进程的通信

# 进程间同步的方式

1）临界区：通过对多个线程的串行化来实现进程间的同步
2）互斥量：
3） 信号量：为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同 一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号 量的一种特殊情况，当信号量的最大资源数=1 就是互斥量了。
4）事件：



# java的线程和go的协程

Java的线程是由操作系统内核来调度和管理的，它们是操作系统级别的实体。Java程序启动时，每个线程都会被映射到一个操作系统的线程上，并由操作系统来负责线程的调度和切换。因此，Java的线程对操作系统资源的开销较大。

而Go的协程是由Go语言自身的调度器进行调度和管理的，它们是轻量级的用户态线程。Go语言的调度器会在一个或多个OS线程上运行，但协程的调度和切换是在用户态上完成的，而不是由操作系统内核来控制。这样可以大大减少线程上下文切换的开销，提高程序的并发性能。

此外，Java的线程需要使用锁机制来避免并发访问的问题，而Go的协程则使用了通道（channel）的机制来实现同步和通信，这种机制可以避免很多传统的并发编程问题。

**现今 Java 中线程的本质，其实就是操作系统中的线程，其线程库和线程模型很大程度上依赖于操作系统（宿主系统）的具体实现，比如在 Windows 中 Java 就是基于 Wind32 线程库来管理线程，且 Windows 采用的是一对一的线程模型**。



# 内存 分页和分段区别

核心：主要解决虚拟地址和物理地址的映射关系

1）分段：按照程序的逻辑，分成了栈段、堆栈、数据段、代码段。但是由于每个段的大小都不是统一的，这就回导致内存碎片和内存交换效率低的问题。
2）分页：把虚拟空间和物理空间分成大小固定的页，在linux系统中，每一页的大小为4kb，内存交换的时候直接使用页进行交换，减少细小的内存碎片。


**Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理**。于是 Linux 就把所有段的基地址设为 `0`，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。


另外，Linxu 系统中虚拟空间分布可分为**用户态**和**内核态**两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。



# 什么是硬中断、软中断

1）硬中断是由硬件设备引起的中断，例如CPU硬件时钟、网卡中断等。当硬件设备需要CPU的处理时，会向CPU发送中断信号。CPU会暂停当前的工作，并调用预定义的中断处理程序（interrupt handler）来处理中断事件。

2）软中断是由内核软件（kernel software）引起的中断。软中断是一种由内核处理的中断，通常与网络数据包、磁盘IO等操作相关。与硬中断不同，软中断不由硬件设备引发，而是由内核代码中某些特定条件的触发。


# 什么是I/O 多路复用

**I/O多路复用是指通过一种机制，使单个进程能够同时监听多个文件描述符，等待它们中的任意一个变为可读或可写，从而实现并发地处理多个I/O操作。**

1）select

底层采用数组

执行流程：假设进程A同时监听socket1、socket2、socket3，当任何一个socket上收到数据时，中断程序将唤起进程。所谓唤起进程，就是将其从所有的socket对象的等待队列中移除，并插入到就绪队列中。经过这两步之后，当进程A被唤醒时，它知道它所检测的socket列表中至少有个socket已经接收到数据了。此时程序遍历一遍socket列表，就可以得到就绪的socket。

缺点：
1.  每次调用select都需要将进程加入到所有socket对象的等待队列中，每次唤醒进程又要将进程从所有socket对象的等待队列中移除。这里涉及到对socket列表的两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket（强行修改也是可以的）；
2.  进程被唤醒后，程序并不知道socket列表中的那些socket上收到数据，因此在用户空间内需要对socket列表再做一次遍历。

2）poll

poll模型：poll模型是select模型的改进版，它使用链表管理文件描述符，可以支持任意数量的文件描述符，避免了select模型中最大文件描述符数量的限制。但是，poll模型的效率也不够高，因为每次调用poll函数时，都需要把所有的文件描述符从用户空间拷贝到内核空间，造成了一定的开销

3）epoll

epoll模型使用红黑树存储文件描述符，当有I/O事件发生时，只需要通知相应的文件描述符即可，不需要像select和poll模型一样遍历所有文件描述符，
使用事件监听队列，当出现就绪的socket之后，再去通知进程，这样立即知道那个socket准备完毕。不需要从头到尾遍历socket。



# 什么是死锁？死锁产生的条件？

什么是死锁：在多个并发进程中，如果每个进程持有某种资源而又等待其他进程持有的资源，在未能改变这种状态的之前，都不能向前推进。

死锁产生的四个必要条件：（四个必须要同时出现，破坏其中一个就能防止死锁产生）
1）互斥条件：一个资源一次只能被一个进程使用
2）请求和保持条件：一个进程因请求资源被阻塞的时候，对已经获取的资源保持不放
3）不可剥夺：进程获得的资源，在未完全使用完之前，不能强行剥夺。
4）循环等待：若干个进程之间形成一种首尾相接的环形等待资源关系。

