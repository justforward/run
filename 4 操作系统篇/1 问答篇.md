
# 什么是硬中断、软中断

1）硬中断是由硬件设备引起的中断，例如CPU硬件时钟、网卡中断等。当硬件设备需要CPU的处理时，会向CPU发送中断信号。CPU会暂停当前的工作，并调用预定义的中断处理程序（interrupt handler）来处理中断事件。

2）软中断是由内核软件（kernel software）引起的中断。软中断是一种由内核处理的中断，通常与网络数据包、磁盘IO等操作相关。与硬中断不同，软中断不由硬件设备引发，而是由内核代码中某些特定条件的触发。


# 什么是I/O 多路复用

**I/O多路复用是指通过一种机制，使单个进程能够同时监听多个文件描述符，等待它们中的任意一个变为可读或可写，从而实现并发地处理多个I/O操作。**

1）select

底层采用数组

执行流程：假设进程A同时监听socket1、socket2、socket3，当任何一个socket上收到数据时，中断程序将唤起进程。所谓唤起进程，就是将其从所有的socket对象的等待队列中移除，并插入到就绪队列中。经过这两步之后，当进程A被唤醒时，它知道它所检测的socket列表中至少有个socket已经接收到数据了。此时程序遍历一遍socket列表，就可以得到就绪的socket。

缺点：
1.  每次调用select都需要将进程加入到所有socket对象的等待队列中，每次唤醒进程又要将进程从所有socket对象的等待队列中移除。这里涉及到对socket列表的两次遍历，而且每次都要将整个fds列表传递给内核，有一定的开销。正因为遍历操作开销大，出于效率的考量，才会规定select的最大监视数量，默认只能监视1024个socket（强行修改也是可以的）；
2.  进程被唤醒后，程序并不知道socket列表中的那些socket上收到数据，因此在用户空间内需要对socket列表再做一次遍历。

2）poll

poll模型：poll模型是select模型的改进版，它使用链表管理文件描述符，可以支持任意数量的文件描述符，避免了select模型中最大文件描述符数量的限制。但是，poll模型的效率也不够高，因为每次调用poll函数时，都需要把所有的文件描述符从用户空间拷贝到内核空间，造成了一定的开销

3）epoll

epoll模型使用红黑树存储文件描述符，当有I/O事件发生时，只需要通知相应的文件描述符即可，不需要像select和poll模型一样遍历所有文件描述符，
使用事件监听队列，当出现就绪的socket之后，再去通知进程，这样立即知道那个socket准备完毕。不需要从头到尾遍历socket。



# 什么是死锁？死锁产生的条件？

什么是死锁：在多个并发进程中，如果每个进程持有某种资源而又等待其他进程持有的资源，在未能改变这种状态的之前，都不能向前推进。

死锁产生的四个必要条件：（四个必须要同时出现，破坏其中一个就能防止死锁产生）
1）互斥条件：一个资源一次只能被一个进程使用
2）请求和保持条件：一个进程因请求资源被阻塞的时候，对已经获取的资源保持不放
3）不可剥夺：进程获得的资源，在未完全使用完之前，不能强行剥夺。
4）循环等待：若干个进程之间形成一种首尾相接的环形等待资源关系。

