
## kafka mmap() 

Kafka使用了MMP（Memory Mapped Files）技术，将磁盘上的数据文件映射到内存中进行读写，提高了数据的读写效率。将一个进程的地址空间的一块虚拟地址映射到磁盘地址中：用户态缓冲区和内核态缓冲区的直接映射，减少用户态缓冲区和内核态缓冲区的copy

用户态直接I/O：用户态缓冲区与磁盘进行映射

Kafka中的数据文件被划分成若干个固定大小的片段（segment），每个片段被映射到内存中的一个MMP文件中。在生产者向Kafka发送消息时，消息会被追加到当前片段的末尾，同时内存中的MMP文件也会被更新。在消费者消费消息时，消费者会将内存中的MMP文件映射到自己的地址空间中，并从中读取数据。

通过MMP技术，Kafka避免了磁盘与内存之间的频繁数据拷贝，提高了数据的读写效率，并且在大规模数据场景下能够有效地提高系统的性能。同时，由于Kafka的MMP文件只是内存映射，因此即使Kafka重启或者进程崩溃，数据也不会丢失。





## Kafka sendfile


当生产者向Kafka发送消息时，消息首先被写入内存中的缓冲区，然后Kafka会使用sendfile()系统调用将缓冲区中的数据直接写入到页缓存中，避免了将数据从内核缓冲区复制到用户空间缓冲区再复制到内核缓冲区的过程，这样就避免了多次数据复制，从而实现了零拷贝。

在消费者消费消息时，Kafka也使用了sendfile()系统调用。消费者会从页缓存中读取消息，然后将消息直接传递给应用程序，避免了将数据从内核缓冲区复制到用户空间缓冲区的过程，从而提高了读取数据的效率。

除此之外，在Kafka的复制机制中，当Kafka的broker从一个节点复制数据到另一个节点时，也使用了sendfile()系统调用来实现零拷贝，避免了数据的多次复制。

综上所述，Kafka在数据的写入和读取以及复制过程中使用了sendfile()系统调用来实现零拷贝，提高了数据传输的效率和系统的性能




我们来重点探究 kafka两个重要过程、以及是如何利用两个零拷贝技术sendfile和mmap的。

## 网络数据持久化到磁盘 (Producer 到 Broker)

传统的I/O 过程：先从网卡->socket 缓冲区读取数据，然后再写入到磁盘中。

![[Pasted image 20230226123110.png]]

对于kafka来说，Producer生产的数据存到broker，这个过程读取到socket buffer的网络数据，其实可以直接在OS内核缓冲区，完成落盘。并没有必要将socket buffer的网络数据，读取到应用进程缓冲区；在这里应用进程缓冲区其实就是broker，broker收到生产者的数据，就是为了持久化。

直接完成用户态缓冲区和内核态缓冲区的映射：

它的工作原理是直接利用操作系统的Page来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。

通过mmap，进程像读写硬盘一样读写内存（当然是虚拟机内存），也不必关心内存的大小有虚拟内存为我们兜底。  
使用这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销。

mmap也有一个很明显的缺陷——不可靠，写到mmap中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用flush的时候才把数据真正的写到硬盘。Kafka提供了一个参数——producer.type来控制是不是主动flush；如果Kafka写入到mmap之后就立即flush然后再返回Producer叫同步(sync)；写入mmap之后立即返回Producer不调用flush叫异步(async)。


## 磁盘文件通过网络发送（Broker 到 Consumer）

传统方式实现：  
先读取磁盘、再用socket发送，实际也是进过四次copy。

而 Linux 2.4+ 内核通过 sendfile 系统调用，提供了零拷贝。磁盘数据通过 DMA 拷贝到内核态 Buffer 后，直接通过 DMA 拷贝到 NIC Buffer(socket buffer)，无需 CPU 拷贝。这也是零拷贝这一说法的来源。除了减少数据拷贝外，因为整个读文件 - 网络发送由一个 sendfile 调用完成，整个过程只有两次上下文切换，因此大大提高了性能。零拷贝过程如下图所示。
![[Pasted image 20230226123421.png]]

对传统IO 4步拷贝的分析，减少一次CPU的拷贝。
 传统的I/O 方式：
![[Pasted image 20230226123547.png]]




